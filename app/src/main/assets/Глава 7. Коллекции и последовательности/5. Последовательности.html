<html lang="ru"><head>





<link href="../style/css.css" rel="stylesheet"></head>
<body>
<div id="container">

<div class="outercontainer">
<div class="innercontainer">
 
   <div class="item center menC">
     <h2>Последовательности</h2>
	

	<div style="margin-top:23px;margin-left:5px;">
		
		
		<!-- Yandex.RTB R-A-201190-1 -->
		
	</div>

	<p>Наряду с коллекциями Kotlin предоставляет еще один тип наборов элементов – <span class="b">последовательности</span> 
(sequences). Последовательности предоставляют похожую функциональность, что и интерфейс Iterable, который реализуется типами 
коллекций.  Ключевая разница состоит в том, как обрабатываются элементы последовательности при применении к ним набора операций.</p>
<h3>Создание последовательности</h3>
<h4>Функция sequenceOf</h4>
<p>Последовательности представляют интерфейс <span class="b">Sequence&lt;T&gt;</span>. Для создания объекта данного типа можно использовать 
встроенную функцию <span class="b">sequenceOf()</span>. В качестве параметра она принимает набор элементов, которые будут входить 
в последовательность. Например:</p>
<div><div id="highlighter_796859" class="syntaxhighlighter  kt"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="kt keyword">val</code> <code class="kt plain">people = sequenceOf(</code><code class="kt string">"Tom"</code><code class="kt plain">, </code><code class="kt string">"Sam"</code><code class="kt plain">, </code><code class="kt string">"Bob"</code><code class="kt plain">)&nbsp;&nbsp;&nbsp; </code><code class="kt comments">//тип Sequence&lt;String&gt;</code></div><div class="line number2 index1 alt1"><code class="kt plain">println(people.joinToString())&nbsp; </code><code class="kt comments">// Tom, Sam, Bob</code></div></div></td></tr></tbody></table></div></div>
<p>В данном случае определяется последовательность типа <code>Sequence&lt;String&gt;</code>, которая содержит три элемента. 
Для вывода последовательности на консоль применяется ее преобразование в строку с помощью функции <code>joinToString()</code></p>
<h4>Метод asSequence коллекций</h4>
<p>Также можно создать последовательность из объекта  <span class="b">Iterable</span> (например, из объектов типа List или Set), 
используя метод <span class="b">asSequence()</span></p>
<div><div id="highlighter_325897" class="syntaxhighlighter  kt"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="kt keyword">val</code> <code class="kt plain">employees = listOf(</code><code class="kt string">"Tom"</code><code class="kt plain">, </code><code class="kt string">"Sam"</code><code class="kt plain">, </code><code class="kt string">"Bob"</code><code class="kt plain">) </code><code class="kt comments">// объект List&lt;String&gt;</code></div><div class="line number2 index1 alt1"><code class="kt keyword">val</code> <code class="kt plain">people = employees.asSequence()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="kt comments">//тип Sequence&lt;String&gt;</code></div><div class="line number3 index2 alt2"><code class="kt plain">println(people.joinToString())&nbsp;&nbsp;&nbsp; </code><code class="kt comments">// Tom, Sam, Bob</code></div></div></td></tr></tbody></table></div></div>
<h4>Функция generateSequence</h4>
<p>Третий способ создания последовательности представляет функция <span class="b">generateSequence</span></p>
<div><div id="highlighter_450298" class="syntaxhighlighter  kt"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="kt keyword">var</code> <code class="kt plain">number = 0</code></div><div class="line number2 index1 alt1"><code class="kt keyword">val</code> <code class="kt plain">numbers = generateSequence{ number += 2; number}</code></div><div class="line number3 index2 alt2"><code class="kt plain">println(numbers.take(5).joinToString())&nbsp;&nbsp;&nbsp; </code><code class="kt comments">// получаем первые 5 элементов последовательности - 2, 4, 6, 8, 10</code></div></div></td></tr></tbody></table></div></div>
<p>В качестве параметра функция <code>generateSequence()</code> принимает функцию, которая возвращает некоторое значение. 
Это значение затем станет элементом последовательности. Так в данном случае увеличиваем значение переменной number на 2 и возвращаем ее значение. 
То последовательность будет содержать числа с шагом в 2: 2, 4, 6, 8, 10, 12....</p>
<p>Стоит учитывать, что эта функция по умолчанию генерирует бесконечную последовательность. 
Поэтому в примере выше при выводе элементов на консоль с помощью метода <code>take()</code> получаем только первые пять элементов. Чтобы ограничить 
генерируемую последовательность, функция в <code>generateSequence()</code> должна возвращать null:</p>
<div><div id="highlighter_625822" class="syntaxhighlighter  kt"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="kt keyword">var</code> <code class="kt plain">number = 0</code></div><div class="line number2 index1 alt1"><code class="kt keyword">val</code> <code class="kt plain">numbers = generateSequence{ number += 2; </code><code class="kt keyword">if</code><code class="kt plain">(number &gt; 8) </code><code class="kt keyword">null</code> <code class="kt keyword">else</code> <code class="kt plain">number}</code></div><div class="line number3 index2 alt2"><code class="kt plain">println(numbers.joinToString())&nbsp;&nbsp;&nbsp; </code><code class="kt comments">// 2, 4, 6, 8</code></div></div></td></tr></tbody></table></div></div>
<p>В данном случае последовательность содержит только числа от 2 до 8 включительно.</p>
<p>Функция <code>generateSequence()</code> имеет несколько вариаций. В частности, в качестве первого параметра мы можем 
передать первое значение по умолчанию, а второй параметр по прежнему представляет функцию, которая генерирует последовательность</p>
<div><div id="highlighter_751411" class="syntaxhighlighter  kt"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="kt keyword">val</code> <code class="kt plain">numbers = generateSequence(5){ </code><code class="kt keyword">if</code><code class="kt plain">(it == 25) </code><code class="kt keyword">null</code> <code class="kt keyword">else</code> <code class="kt plain">it + 5}</code></div><div class="line number2 index1 alt1"><code class="kt plain">println(numbers.joinToString())&nbsp;&nbsp;&nbsp; </code><code class="kt comments">// 5, 10, 15, 20, 25</code></div></div></td></tr></tbody></table></div></div>
<p>В данном случае в функцию первому параметру передается число 5, то есть это будет первый элемент последовательности. 
Функция создания последовательности через параметр it получает предыдущий результат функции - фактически предыдущий элемент последовательности 
(при первом вызове функции - это значение первого параметра). 
В данном случае создается конечная последовательность, где каждый последующий элемент больше предыдущего на 5. Если 
последний элемент равен 25, то возвращаем null, тем самым завершаем генерацию последовательности. Стоит отметить, 
что даже если функция возвратит null, то последовательность будет содержать один элемент: <code>generateSequence(5){ null }</code></p>
<h4>Функция sequence</h4>
<p>Четвертый способ представляет применение функции <span class="b">sequence()</span>. В этой функции можно генерировать 
элементы последовательности с помощью функций <span class="b">yield()</span> и <span class="b">yieldAll()</span>:</p>
<div><div id="highlighter_964639" class="syntaxhighlighter  kt"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="kt keyword">val</code> <code class="kt plain">numbers = sequence {</code></div><div class="line number2 index1 alt1"><code class="kt spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="kt plain">yield(1)</code></div><div class="line number3 index2 alt2"><code class="kt spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="kt plain">yield(4)</code></div><div class="line number4 index3 alt1"><code class="kt spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="kt plain">yield(7)</code></div><div class="line number5 index4 alt2"><code class="kt plain">}</code></div><div class="line number6 index5 alt1"><code class="kt plain">println(numbers.joinToString())&nbsp;&nbsp;&nbsp; </code><code class="kt comments">// 1, 4, 7</code></div></div></td></tr></tbody></table></div></div>
<p>Функция <span class="b">yield()</span> фактически возвращает во вне некоторое значение, которое ей передается через параметр. 
То есть при первом обращении к функции sequence сработает вызов <code>yield(1)</code>, который возвратит значение 1. При втором обращении 
сработает вызов <code>yield(4)</code>, который возвратит 4. И при третьем обращении сработает вызов <code>yield(7)</code>. 
Таким образом, последовательность будет содержать 3 элемента: 1, 4, 7.</p>
<p>Можно создать и бесконечную последовательность:</p>
<div><div id="highlighter_585941" class="syntaxhighlighter  kt"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="kt keyword">val</code> <code class="kt plain">numbers = sequence {</code></div><div class="line number2 index1 alt1"><code class="kt spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="kt keyword">var</code> <code class="kt plain">start = 0</code></div><div class="line number3 index2 alt2"><code class="kt spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="kt keyword">while</code><code class="kt plain">(</code><code class="kt keyword">true</code><code class="kt plain">) yield(start++)</code></div><div class="line number4 index3 alt1"><code class="kt plain">}</code></div><div class="line number5 index4 alt2"><code class="kt plain">println(numbers.take(5).joinToString())&nbsp;&nbsp;&nbsp; </code><code class="kt comments">// 0, 1, 2, 3, 4</code></div></div></td></tr></tbody></table></div></div>
<p>Здесь при каждом обращении к функции sequence возвращается одно из чисел начиная с 0.</p>
<p>Если надо создать последовательности на основе другой последовательности или коллекции, то удобнее источник данных передать 
в функцию <span class="b">yieldAll()</span></p>
<div><div id="highlighter_60938" class="syntaxhighlighter  kt"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="kt keyword">val</code> <code class="kt plain">personal = sequence {</code></div><div class="line number2 index1 alt1"><code class="kt spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="kt keyword">val</code> <code class="kt plain">data = listOf(</code><code class="kt string">"Alice"</code><code class="kt plain">, </code><code class="kt string">"Kate"</code><code class="kt plain">, </code><code class="kt string">"Ann"</code><code class="kt plain">)</code></div><div class="line number3 index2 alt2"><code class="kt spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="kt plain">yieldAll(data)</code></div><div class="line number4 index3 alt1"><code class="kt plain">}</code></div><div class="line number5 index4 alt2"><code class="kt plain">println(personal.joinToString())&nbsp;&nbsp;&nbsp; </code><code class="kt comments">// Alice, Kate, Ann</code></div></div></td></tr></tbody></table></div></div>
<h3>Перебор последовательности</h3>
<p>Для перебора последовательности можно применять стандартный цикл <span class="b">for</span>:</p>
<div><div id="highlighter_670213" class="syntaxhighlighter  kt"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="kt keyword">val</code> <code class="kt plain">people = sequenceOf(</code><code class="kt string">"Tom"</code><code class="kt plain">, </code><code class="kt string">"Sam"</code><code class="kt plain">, </code><code class="kt string">"Bob"</code><code class="kt plain">)</code></div><div class="line number2 index1 alt1"><code class="kt keyword">for</code><code class="kt plain">(person </code><code class="kt keyword">in</code> <code class="kt plain">people) println(person)</code></div></div></td></tr></tbody></table></div></div>
<h3>Операции с последовательностями</h3>
<p>Интерфейс <span class="b">Sequence</span> предоставляет ряд функций, который позволяют производить различные операции с последовательностями. 
Все операции с последовательностями делятся на ряд типов.</p>
<p>Прежде всего операции различаются по наличию состояния. Одни операции могут хранить состояние (statefull-операции), например, операция <code>distinct()</code>. 
Подобное состояние обычно пропорционально количеству элементов в последовательности. А есть операции, которые не имеют состояния (stateless-операции), например, 
функции <code>map()</code> и <code>filter()</code>, или требуют очень небольшого константного состояния, как функции <code>take()</code> и <code>drop()</code>. 
Подобные операции обрабатывают каждый элемент независимо от других.</p>
<p>Другая классификация операций основывается на том, когда выполняется операции. В данном случае они бывают промежуточными (intermediate) - такие операции 
обычно возвращают другую последовательность. Они НЕ выполняются сразу при их вызове.</p>
<p>А есть терминальные или конечные операции (terminal). Такие операции подразумевают извлечение элементов последовательности, например, когда нам надо получить 
количество элементов с помощью функции <code>count()</code> или элемент по индексу. Такие операции выполняются сразу при их вызове. То же самое можно сказать 
о переборе с помощью цикла for, который извлекает элементы из последовательности и соответственно также запускает процесс выполнения всех операций последовательности.</p>
<p>Рассмотрим основные операции:</p>
<ul>
<li><p><span class="b">all(predicate: (T) -&gt; Boolean): Boolean</span></p>
<p>возвращает <code>true</code>, если все элементы соответствуют предикату, который передается в функцию в качестве параметра</p>
<p>Терминальная операция</p></li>

<li><p><span class="b">any(): Boolean</span></p>
<p>возвращает <code>true</code>, если последовательность содержит хотя бы один элемент</p>
<p>Дополнительная версия возвращает <code>true</code>, если хотя бы один элемент соответствуют предикату, который передается в функцию в качестве параметра</p>
<p><span class="b">any(predicate: (T) -&gt; Boolean): Boolean</span></p>
<p>Терминальная операция</p></li>

<li><p><span class="b">average(): Double</span></p>
<p>возвращает среднее значение для числовой последовательности типов Byte, Int, Short, Long, Float, Double</p></li>

<li><p><span class="b">chunked(size: Int): Sequence&lt;List&lt;T&gt;&gt;</span></p>
<p>расщепляет последовательность на последовательность из списков List, параметр size устанавливает максимальное количество элементов в каждом из списков</p>
<p>Дополнительная версия в качестве второго параметра получает функцию преобразования, которая преобразует каждый список в элемент новой последовательности</p>
<p><span class="b">chunked(size: Int,transform: (List&lt;T&gt;) -&gt; R): Sequence&lt;R&gt;</span></p>
<p>Промежуточная операция</p></li>

<li><p><span class="b">contains(element: T): Boolean</span></p>
<p>возвращает <code>true</code>, если последовательность содержит элемент element</p>
<p>Терминальная операция</p></li>

<li><p><span class="b">count(): Int</span></p>
<p>возвращает количество элементов в последовательности</p>
<p>Дополнительная версия возвращает количество элементов, которые соответствуют предикату</p>
<p><span class="b">count(predicate: (T) -&gt; Boolean): Int</span></p>
<p>Терминальная операция</p></li>

<li><p><span class="b">distinct(): Sequence&lt;T&gt;</span></p>
<p>возвращает новую последовательность, которая содержит только уникальные элементы</p>
<p>Промежуточная операция</p></li>

<li><p><span class="b">distinctBy(selector: (T) -&gt; K): Sequence&lt;T&gt;</span></p>
<p>возвращает новую последовательность, которая содержит только уникальные элементы с учетом функции селектора, которая передается в качестве параметра</p>
<p>Промежуточная операция</p></li>

<li><p><span class="b">drop(n: Int): Sequence&lt;T&gt;</span></p>
<p>возвращает новую последовательность, которая содержит все элементы за исключением первых n элементов</p>
<p>Промежуточная операция</p></li>

<li><p><span class="b">dropWhile(predicate: (T) -&gt; Boolean): Sequence&lt;T&gt;</span></p>
<p>возвращает новую последовательность, которая содержит все элементы за исключением первых элементов, которые соответствуют предикату</p>
<p>Промежуточная операция</p></li>

<li><p><span class="b">elementAt(index: Int): T</span></p>
<p>возвращает элемент по индексу index. Если индекс выходит за пределы последовательности, то генерируется исключение типа IndexOutOfBoundsException </p>
<p>Терминальная операция</p></li>

<li><p><span class="b">elementAtOrElse(index: Int, defaultValue: (Int) -&gt; T): T</span></p>
<p>возвращает элемент по индексу index. Если индекс выходит за пределы последовательности, то возвращается значение, устанавливаемое функцией из параметра defaultValue</p>
<p>Терминальная операция</p></li>

<li><p><span class="b">elementAtOrNull(index: Int): T?</span></p>
<p>возвращает элемент по индексу index. Если индекс выходит за пределы последовательности, то возвращается null</p>
<p>Терминальная операция</p></li>

<li><p><span class="b">filter(predicate: (T) -&gt; Boolean): Sequence&lt;T&gt;</span></p>
<p>возвращает новую последовательность из элементов, которые соответствуют предикату</p>
<p>Промежуточная операция</p></li>

<li><p><span class="b">filterNot(predicate: (T) -&gt; Boolean): Sequence&lt;T&gt;</span></p>
<p>возвращает новую последовательность из элементов, которые НЕ соответствуют предикату</p>
<p>Промежуточная операция</p></li>

<li><p><span class="b">filterNotNull(): Sequence&lt;T&gt;</span></p>
<p>возвращает новую последовательность из элементов, которые не равны null</p>
<p>Промежуточная операция</p></li>


<li><p><span class="b">find(predicate: (T) -&gt; Boolean): T?</span></p>
<p>возвращает первый элемент, который соответствует предикату. Если элемент не найден, то возвращается null</p>
<p>Терминальная операция</p></li>

<li><p><span class="b">findLast(predicate: (T) -&gt; Boolean): T?</span></p>
<p>возвращает последний элемент, который соответствует предикату. Если элемент не найден, то возвращается null</p>
<p>Терминальная операция</p></li>

<li><p><span class="b">first(): T</span></p>
<p>возвращает первый элемент последовательности</p>
<p>Дополнительная версия возвращает первый элемент, которые соответствует предикату</p>
<p><span class="b">first(predicate: (T) -&gt; Boolean): T</span></p>
<p>Если элемент не найден, то генерируется исключение типа NoSuchElementException</p>
<p>Терминальная операция</p></li>

<li><p><span class="b">firstOrNull(): T?</span></p>
<p>возвращает первый элемент последовательности</p>
<p>Дополнительная версия возвращает первый элемент, которые соответствует предикату</p>
<p><span class="b">firstOrNull(predicate: (T) -&gt; Boolean): T?</span></p>
<p>Если элемент не найден, то возвращается null</p>
<p>Терминальная операция</p></li>
<li><p><span class="b">flatMap(transform: (T) -&gt; Sequence&lt;R&gt;): Sequence&lt;R&gt;</span></p>
<p>преобразует последовательность элементов типа T в последовательность элементов типа R, используя функцию преобразования, которая передается в качестве параметра</p>
<p>Промежуточная операция</p></li>
<li><p><span class="b">fold(initial: R, operation: (acc: R, T) -&gt; R): R</span></p>
<p>Возвращает значение, которое является результатом действия функции operation над каждым элементом последовательности. Первый параметр функции 
operation - результат работы функции над предыдущим элементом последовательности (при первом вызове - значение из параметра initial), в 
второй параметр - текущий элемент последовательности.</p>
<p>Терминальная операция</p></li>

<li><p><span class="b">forEach(action: (T) -&gt; Unit)</span></p>
<p>Выполняет для каждого элемента последовательности действие action.</p>
<p>Терминальная операция</p></li>

<li><p><span class="b">groupBy(keySelector: (T) -&gt; K): Map&lt;K, List&lt;T&gt;&gt;</span></p>
<p>Группирует элементы по ключу, который возвращается функцией keySelector. Результат функции карта Map, где ключ - собственно ключ элементов, а значение - 
список List из элементов, которые соответствуют этому ключу</p>
<p>Дополнительная версия принимает функцию преобразования элементов:</p>
<p><span class="b">groupBy(keySelector: (T) -&gt; K, valueTransform: (T) -&gt; V): Map&lt;K, List&lt;V&gt;&gt;</span></p>
<p>Терминальная операция</p></li>

<li><p><span class="b">indexOf(element: T): Int</span></p>
<p>Возвращает индекс первого вхождения элемента element. Если элемент не найден, возвращается -1</p>
<p>Терминальная операция</p></li>
<li><p><span class="b">indexOfFirst(predicate: (T) -&gt; Boolean): Int</span></p>
<p>Возвращает индекс первого элемента, который соответствует предикату. Если элемент не найден, возвращается -1</p>
<p>Терминальная операция</p></li>
<li><p><span class="b">indexOfLast(predicate: (T) -&gt; Boolean): Int</span></p>
<p>Возвращает индекс последнего элемента, который соответствует предикату. Если элемент не найден, возвращается -1</p>
<p>Терминальная операция</p></li>
<li><p><span class="b">joinToString(): String</span></p>
<p>Генерирует из последовательности строку</p>
<p>Терминальная операция</p></li>

<li><p><span class="b">last(): T</span></p>
<p>возвращает последний элемент последовательности</p>
<p>Дополнительная версия возвращает последний элемент, которые соответствует предикату</p>
<p><span class="b">last(predicate: (T) -&gt; Boolean): T</span></p>
<p>Если элемент не найден, то генерируется исключение типа NoSuchElementException</p>
<p>Терминальная операция</p></li>

<li><p><span class="b">lastOrNull(): T?</span></p>
<p>возвращает последний элемент последовательности</p>
<p>Дополнительная версия возвращает последний элемент, которые соответствует предикату</p>
<p><span class="b">lastOrNull(predicate: (T) -&gt; Boolean): T?</span></p>
<p>Если элемент не найден, то возвращается null</p>
<p>Терминальная операция</p></li>

<li><p><span class="b">lastIndexOf(element: T): Int</span></p>
<p>Возвращает последний индекс элемента element. Если элемент не найден, возвращается -1</p>
<p>Терминальная операция</p></li>

<li><p><span class="b">map(transform: (T) -&gt; R): Sequence&lt;R&gt;</span></p>
<p>Применяет к элементам последовательности функцию трансформации и возвращает новую последовательность из новых элементов</p>
<p>Промежуточная операция</p></li>

<li><p><span class="b">mapIndexed(transform: (index: Int, T) -&gt; R): Sequence&lt;R&gt;</span></p>
<p>Применяет к элементам последовательности и их индексам функцию трансформации и возвращает новую последовательность из новых элементов</p>
<p>Промежуточная операция</p></li>


<li><p><span class="b">mapNotNull(transform: (T) -&gt; R?): Sequence&lt;R&gt;</span></p>
<p>Применяет к элементам последовательности функцию трансформации и возвращает новую последовательность из новых элементов, которые не равны null</p>
<p>Промежуточная операция</p></li>


<li><p><span class="b">maxOf(selector: (T) -&gt; Double): Double</span></p>
<p>Возвращает максимальное значение на основе селектора</p>
<p>Терминальная операция</p></li>
<li><p><span class="b">maxOfOrNull(selector: (T) -&gt; Double): Double?</span></p>
<p>Возвращает максимальное значение на основе селектора. Если последовательность пуста, возвращается null</p>
<p>Терминальная операция</p></li>
<li><p><span class="b">maxOrNull(): Double?</span></p>
<p>Возвращает максимальное значение. Если последовательность пуста, возвращается null</p>
<p>Терминальная операция</p></li>
<li><p><span class="b">minOf(selector: (T) -&gt; Double): Double</span></p>
<p>Возвращает минимальное значение на основе селектора</p>
<p>Терминальная операция</p></li>
<li><p><span class="b">minOfOrNull(selector: (T) -&gt; Double): Double?</span></p>
<p>Возвращает минимальное значение на основе селектора. Если последовательность пуста, возвращается null</p>
<p>Терминальная операция</p></li>
<li><p><span class="b">minOrNull(): Double?</span></p>
<p>Возвращает минимальное значение. Если последовательность пуста, возвращается null</p>
<p>Терминальная операция</p></li>
<li><p><span class="b">minus(element: T): Sequence&lt;T&gt;</span></p>
<p>Возвращает новую последовательность, которая содержит все элементы текущей за исключением элемента element.</p>
<p>Имеет разновидности, которую позволяют исключить из последовательности наборы элементов:</p>
<div><div id="highlighter_308096" class="syntaxhighlighter  kt"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="kt plain">minus(elements: Array&lt;T&gt;): Sequence&lt;T&gt;</code></div><div class="line number2 index1 alt1"><code class="kt plain">minus(elements: Iterable&lt;T&gt;): Sequence&lt;T&gt;</code></div><div class="line number3 index2 alt2"><code class="kt plain">minus(elements: Sequence&lt;T&gt;): Sequence&lt;T&gt;</code></div></div></td></tr></tbody></table></div></div>
<p>Промежуточная операция</p></li>
<li><p><span class="b">plus(element: T): Sequence&lt;T&gt;</span></p>
<p>Возвращает новую последовательность, которая содержит все элементы текущей за исключением плюс элемент element.</p>
<p>Имеет разновидности, которую позволяют включить в последовательность наборы элементов:</p>
<div><div id="highlighter_12180" class="syntaxhighlighter  kt"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="kt plain">plus(elements: Array&lt;T&gt;): Sequence&lt;T&gt;</code></div><div class="line number2 index1 alt1"><code class="kt plain">plus(elements: Iterable&lt;T&gt;): Sequence&lt;T&gt;</code></div><div class="line number3 index2 alt2"><code class="kt plain">plus(elements: Sequence&lt;T&gt;): Sequence&lt;T&gt;</code></div></div></td></tr></tbody></table></div></div>
<p>Промежуточная операция</p></li>
<li><p><span class="b">reduce(operation: (acc: S, T) -&gt; S): S</span></p>
<p>Возвращает значение, которое является результатом действия функции operation над каждым элементом последовательности. Первый параметр функции 
operation - результат работы функции над предыдущим элементом последовательности, в 
второй параметр - текущий элемент последовательности.</p>
<p>Терминальная операция</p></li>

<li><p><span class="b">shuffled(): Sequence&lt;T&gt;</span></p>
<p>Условно перемешивает последовательность</p>
<p>Промежуточная операция</p></li>

<li><p><span class="b">sorted(): Sequence&lt;T&gt;</span></p>
<p>Сортирует последовательность по возрастанию</p>
<p>Промежуточная операция</p></li>
<li><p><span class="b">sortedBy(selector: (T) -&gt; R?): Sequence&lt;T&gt;</span></p>
<p>Сортирует последовательность по возрастанию на основе селектора</p>
<p>Промежуточная операция</p></li>
<li><p><span class="b">sortedByDescending(selector: (T) -&gt; R?): Sequence&lt;T&gt;</span></p>
<p>Сортирует последовательность по убыванию на основе функции-селектора</p>
<p>Промежуточная операция</p></li>
<li><p><span class="b">sortedDescending(): Sequence&lt;T&gt;</span></p>
<p>Сортирует последовательность по убыванию</p>
<p>Промежуточная операция</p></li>
<li><p><span class="b">sum(): Int</span></p>
<p>Возвращает сумму элементов последовательности.</p>
<p>Терминальная операция</p></li> 
<li><p><span class="b">sumOf(selector: (T) -&gt; Int): Int</span></p>
<p>Возвращает сумму элементов последовательности на основе функции-селектора</p>
<p>Терминальная операция</p></li> 
<li><p><span class="b">take(n: Int): Sequence&lt;T&gt;</span></p>
<p>Возвращает новую последовательность, которая содержит n первых элементов текущей последовательности</p>
<p>Промежуточная операция</p></li> 
<li><p><span class="b">takeWhile(predicate: (T) -&gt; Boolean): Sequence&lt;T&gt;</span></p>
<p>Возвращает новую последовательность, которая содержит n первых элементов текущей последовательности, соответствующих функции-предикату</p>
<p>Промежуточная операция</p></li>
<li><p><span class="b">toHashSet(): HashSet&lt;T&gt;</span></p>
<p>Создает из последовательности объект HashSet</p>
<p>Терминальная операция</p></li> 
<li><p><span class="b">toList(): List&lt;T&gt;</span></p>
<p>Создает из последовательности объект List</p>
<p>Терминальная операция</p></li> 
<li><p><span class="b">toMap(): Map&lt;K, V&gt;</span></p>
<p>Создает из последовательности объект Map</p>
<p>Терминальная операция</p></li> 
<li><p><span class="b">toSet(): Set&lt;T&gt;</span></p>
<p>Создает из последовательности объект Set</p>
<p>Терминальная операция</p></li> 
</ul>
	
	<div style="margin-top:25px;">

	
	</div>

	
	

	<div class="commentABl" style="clear:both;margin: 25px 5px 15px 5px;">
	
	
	
	</div>

	
	

  </div>

	
</div>

  
</div>


</div>














</body></html>